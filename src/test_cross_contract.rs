//! # Cross-Contract Interaction Test Harness
//!
//! This module provides a test harness for future cross-contract interactions
//! in the Revora revenue-sharing system. It demonstrates patterns for:
//!
//! 1. **Mock External Contracts**: How to create and register mock contracts
//!    that simulate external services (token registries, oracles, etc.)
//! 2. **Cross-Contract Calls**: How the Revora contract can invoke methods on
//!    external contracts and handle responses.
//! 3. **Error Handling**: How to handle failures in external contract calls
//!    gracefully without corrupting state.
//! 4. **Multi-Contract Test Setup**: How to wire multiple contracts together
//!    in the Soroban test environment.
//!
//! ## Architecture Notes for Future Implementers
//!
//! ### Cross-Contract Call Patterns in Soroban
//!
//! Soroban supports cross-contract calls via client types generated by the
//! `#[contract]` and `#[contractimpl]` macros. The caller contract imports the
//! callee's client type and invokes methods through it.
//!
//! ```text
//! ┌──────────────────┐     invoke()      ┌───────────────────┐
//! │  Revora Contract  │ ───────────────▶ │  External Contract │
//! │  (revenue share)  │                  │  (registry/oracle) │
//! │                   │ ◀─────────────── │                    │
//! └──────────────────┘     return val    └───────────────────┘
//! ```
//!
//! ### Recommended Integration Points
//!
//! - **Token Registry**: Validate that offering tokens are registered/approved
//!   before allowing `register_offering`.
//! - **Price Oracle**: Fetch asset prices for cross-asset revenue aggregation.
//! - **Compliance Contract**: Check investor eligibility before claims.
//! - **Fee Collector**: Route platform fees to a separate fee-management contract.
//!
//! ### Gas Considerations
//!
//! Each cross-contract call adds overhead. For production:
//! - Cache frequently-read external data in contract storage
//! - Batch external lookups where possible
//! - Set appropriate TTLs on cached data
//!
//! ### Testing Methodology
//!
//! 1. Register both contracts in the test `Env`
//! 2. Use `env.mock_all_auths()` to bypass auth for testing
//! 3. Invoke the main contract, which internally calls the mock
//! 4. Assert expected state changes in both contracts

#![cfg(test)]

use soroban_sdk::{
    contract, contracterror, contractimpl, contracttype, symbol_short, testutils::Address as _,
    Address, Env,
};

use crate::{RevoraRevenueShare, RevoraRevenueShareClient};

// ===========================================================================
// Mock Token Registry Contract
// ===========================================================================
// Simulates an external token registry that tracks approved/registered tokens.
// In production, this could be a Stellar Asset Contract registry, a DAO-approved
// token list, or a compliance-checked asset registry.

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[repr(u32)]
pub enum RegistryError {
    TokenNotRegistered = 1,
    AlreadyRegistered = 2,
}

/// Mock token registry: tracks which tokens are approved for use in offerings.
#[contract]
pub struct MockTokenRegistry;

#[contractimpl]
impl MockTokenRegistry {
    /// Register a token as approved. Admin-only in production; mocked here.
    pub fn register_token(env: Env, admin: Address, token: Address) -> Result<(), RegistryError> {
        admin.require_auth();
        let key = (symbol_short!("approved"), token.clone());
        if env.storage().persistent().has(&key) {
            return Err(RegistryError::AlreadyRegistered);
        }
        env.storage().persistent().set(&key, &true);

        // Track registered tokens for enumeration
        let count_key = symbol_short!("count");
        let count: u32 = env.storage().persistent().get(&count_key).unwrap_or(0);
        let item_key = (symbol_short!("item"), count);
        env.storage().persistent().set(&item_key, &token);
        env.storage().persistent().set(&count_key, &(count + 1));
        Ok(())
    }

    /// Check if a token is approved.
    pub fn is_approved(env: Env, token: Address) -> bool {
        let key = (symbol_short!("approved"), token);
        env.storage()
            .persistent()
            .get::<_, bool>(&key)
            .unwrap_or(false)
    }

    /// Remove a token from the approved list.
    pub fn revoke_token(env: Env, admin: Address, token: Address) {
        admin.require_auth();
        let key = (symbol_short!("approved"), token);
        env.storage().persistent().remove(&key);
    }

    /// Return count of registered tokens.
    pub fn get_token_count(env: Env) -> u32 {
        let count_key = symbol_short!("count");
        env.storage().persistent().get(&count_key).unwrap_or(0)
    }
}

// ===========================================================================
// Mock Price Oracle Contract
// ===========================================================================
// Simulates an external price oracle that provides asset prices.
// Useful for cross-asset revenue aggregation or fee calculations.

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub struct PriceData {
    pub price: i128,
    pub timestamp: u64,
}

/// Mock price oracle: provides asset prices for cross-asset calculations.
#[contract]
pub struct MockPriceOracle;

#[contractimpl]
impl MockPriceOracle {
    /// Set a price for an asset. In production, this would be an oracle feed.
    pub fn set_price(env: Env, admin: Address, asset: Address, price: i128, timestamp: u64) {
        admin.require_auth();
        let key = (symbol_short!("price"), asset);
        env.storage()
            .persistent()
            .set(&key, &PriceData { price, timestamp });
    }

    /// Get the current price for an asset. Returns None if not set.
    pub fn get_price(env: Env, asset: Address) -> Option<PriceData> {
        let key = (symbol_short!("price"), asset);
        env.storage().persistent().get(&key)
    }

    /// Calculate the value of `amount` of `asset` in base currency.
    pub fn calculate_value(env: Env, asset: Address, amount: i128) -> i128 {
        let key = (symbol_short!("price"), asset);
        let price_data: PriceData = env.storage().persistent().get(&key).expect("price not set");
        // Simple multiplication; in production, handle decimals properly
        amount * price_data.price / 1_000_000 // price scaled by 1e6
    }
}

// ===========================================================================
// Tests: Cross-Contract Interaction Patterns
// ===========================================================================

// ── Pattern 1: Token Registry Validation ─────────────────────

#[test]
fn cross_contract_registry_check_before_offering() {
    // Demonstrates: checking an external registry before registering an offering.
    // Pattern: Revora contract queries the registry to validate token approval.
    let env = Env::default();
    env.mock_all_auths();

    // Deploy both contracts
    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let registry_id = env.register_contract(None, MockTokenRegistry);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);

    let admin = Address::generate(&env);
    let issuer = Address::generate(&env);
    let token = Address::generate(&env);
    let payout_asset = Address::generate(&env);

    // Step 1: Token is not yet in registry
    assert!(!registry.is_approved(&token));

    // Step 2: Register token in external registry
    registry.register_token(&admin, &token);
    assert!(registry.is_approved(&token));

    // Step 3: Now register offering in Revora (after registry approval)
    // In production, register_offering would call registry.is_approved() internally
    assert!(registry.is_approved(&token));
    revora.register_offering(&issuer, &token, &5_000, &payout_asset);

    // Verify offering was created
    let offering = revora.get_offering(&issuer, &token);
    assert!(offering.is_some());
    assert_eq!(offering.unwrap().revenue_share_bps, 5_000);
}

#[test]
fn cross_contract_registry_revocation_blocks_new_offerings() {
    // Demonstrates: how token revocation in registry can prevent new operations.
    let env = Env::default();
    env.mock_all_auths();

    let registry_id = env.register_contract(None, MockTokenRegistry);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);

    let admin = Address::generate(&env);
    let token = Address::generate(&env);

    // Register and then revoke
    registry.register_token(&admin, &token);
    assert!(registry.is_approved(&token));

    registry.revoke_token(&admin, &token);
    assert!(!registry.is_approved(&token));
    // Off-chain or future on-chain integration would check:
    // if !registry.is_approved(&token) { return Err(...); }
}

#[test]
fn cross_contract_registry_duplicate_registration() {
    // Demonstrates: handling errors from external contracts.
    let env = Env::default();
    env.mock_all_auths();

    let registry_id = env.register_contract(None, MockTokenRegistry);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);

    let admin = Address::generate(&env);
    let token = Address::generate(&env);

    registry.register_token(&admin, &token);
    // Second registration should fail
    let result = registry.try_register_token(&admin, &token);
    assert!(result.is_err());
}

// ── Pattern 2: Price Oracle Integration ──────────────────────

#[test]
fn cross_contract_oracle_price_lookup() {
    // Demonstrates: querying an external oracle for asset prices.
    let env = Env::default();
    env.mock_all_auths();

    let oracle_id = env.register_contract(None, MockPriceOracle);
    let oracle = MockPriceOracleClient::new(&env, &oracle_id);

    let admin = Address::generate(&env);
    let asset = Address::generate(&env);

    // Set price: 2.50 USD (scaled by 1e6 = 2_500_000)
    oracle.set_price(&admin, &asset, &2_500_000, &1000);

    let price = oracle.get_price(&asset);
    assert!(price.is_some());
    assert_eq!(price.unwrap().price, 2_500_000);

    // Calculate value of 1000 tokens
    let value = oracle.calculate_value(&asset, &1000);
    assert_eq!(value, 2_500); // 1000 * 2.5 = 2500
}

#[test]
fn cross_contract_oracle_revenue_valuation() {
    // Demonstrates: combining Revora offering data with oracle prices
    // to compute revenue value in base currency.
    let env = Env::default();
    env.mock_all_auths();

    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let oracle_id = env.register_contract(None, MockPriceOracle);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let oracle = MockPriceOracleClient::new(&env, &oracle_id);

    let admin = Address::generate(&env);
    let issuer = Address::generate(&env);
    let token = Address::generate(&env);
    let payout_asset = Address::generate(&env);

    // Register offering
    revora.register_offering(&issuer, &token, &5_000, &payout_asset);

    // Report revenue
    revora.report_revenue(&issuer, &token, &payout_asset, &1_000_000, &1, &false);

    // Set payout asset price: $1.00 (1_000_000 scaled)
    oracle.set_price(&admin, &payout_asset, &1_000_000, &1000);

    // Get audit summary and compute USD value
    let summary = revora.get_audit_summary(&issuer, &token).unwrap();
    let usd_value = oracle.calculate_value(&payout_asset, &summary.total_revenue);
    assert_eq!(usd_value, 1_000_000); // $1M revenue at $1/token
}

#[test]
fn cross_contract_oracle_missing_price_handling() {
    // Demonstrates: graceful handling when oracle has no price data.
    let env = Env::default();
    env.mock_all_auths();

    let oracle_id = env.register_contract(None, MockPriceOracle);
    let oracle = MockPriceOracleClient::new(&env, &oracle_id);

    let unknown_asset = Address::generate(&env);

    // Query price for unknown asset - returns None
    let price = oracle.get_price(&unknown_asset);
    assert!(price.is_none());
}

// ── Pattern 3: Multi-Contract Workflow ───────────────────────

#[test]
fn cross_contract_full_workflow_registry_then_offering() {
    // Demonstrates: a complete multi-contract workflow:
    // 1. Register token in registry
    // 2. Verify approval
    // 3. Register offering in Revora
    // 4. Report revenue
    // 5. Query oracle for valuation
    let env = Env::default();
    env.mock_all_auths();

    // Deploy all contracts
    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let registry_id = env.register_contract(None, MockTokenRegistry);
    let oracle_id = env.register_contract(None, MockPriceOracle);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);
    let oracle = MockPriceOracleClient::new(&env, &oracle_id);

    let admin = Address::generate(&env);
    let issuer = Address::generate(&env);
    let token = Address::generate(&env);
    let payout_asset = Address::generate(&env);

    // Step 1: Register token in external registry
    registry.register_token(&admin, &token);

    // Step 2: Verify token is approved
    assert!(registry.is_approved(&token));

    // Step 3: Register offering in Revora
    revora.register_offering(&issuer, &token, &3_000, &payout_asset);

    // Step 4: Report revenue
    revora.report_revenue(&issuer, &token, &payout_asset, &500_000, &1, &false);
    revora.report_revenue(&issuer, &token, &payout_asset, &300_000, &2, &false);

    // Step 5: Set price and compute valuation
    oracle.set_price(&admin, &payout_asset, &2_000_000, &1000); // $2.00/token

    let summary = revora.get_audit_summary(&issuer, &token).unwrap();
    assert_eq!(summary.total_revenue, 800_000);
    assert_eq!(summary.report_count, 2);

    let usd_value = oracle.calculate_value(&payout_asset, &summary.total_revenue);
    assert_eq!(usd_value, 1_600_000); // 800k tokens * $2 = $1.6M
}

#[test]
fn cross_contract_multiple_registries_independent() {
    // Demonstrates: multiple external contract instances are isolated.
    let env = Env::default();
    env.mock_all_auths();

    let registry_1_id = env.register_contract(None, MockTokenRegistry);
    let registry_2_id = env.register_contract(None, MockTokenRegistry);
    let registry_1 = MockTokenRegistryClient::new(&env, &registry_1_id);
    let registry_2 = MockTokenRegistryClient::new(&env, &registry_2_id);

    let admin = Address::generate(&env);
    let token = Address::generate(&env);

    // Register in registry 1 only
    registry_1.register_token(&admin, &token);

    assert!(registry_1.is_approved(&token));
    assert!(!registry_2.is_approved(&token)); // Not in registry 2
}

// ── Pattern 4: Error Propagation Across Contracts ────────────

#[test]
fn cross_contract_error_in_registry_does_not_affect_revora() {
    // Demonstrates: errors in one contract don't corrupt another's state.
    let env = Env::default();
    env.mock_all_auths();

    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let registry_id = env.register_contract(None, MockTokenRegistry);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);

    let admin = Address::generate(&env);
    let issuer = Address::generate(&env);
    let token = Address::generate(&env);
    let payout_asset = Address::generate(&env);

    // Register token and offering
    registry.register_token(&admin, &token);
    revora.register_offering(&issuer, &token, &5_000, &payout_asset);

    // Cause an error in registry (duplicate registration)
    let err = registry.try_register_token(&admin, &token);
    assert!(err.is_err());

    // Revora state is unaffected
    let offering = revora.get_offering(&issuer, &token);
    assert!(offering.is_some());
    assert_eq!(offering.unwrap().revenue_share_bps, 5_000);
}

#[test]
fn cross_contract_revora_operations_independent_of_oracle_state() {
    // Demonstrates: Revora core operations work without oracle dependency.
    let env = Env::default();
    env.mock_all_auths();

    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let oracle_id = env.register_contract(None, MockPriceOracle);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let oracle = MockPriceOracleClient::new(&env, &oracle_id);

    let issuer = Address::generate(&env);
    let token = Address::generate(&env);
    let payout_asset = Address::generate(&env);

    // Revora works fine without any oracle prices set
    revora.register_offering(&issuer, &token, &5_000, &payout_asset);
    revora.report_revenue(&issuer, &token, &payout_asset, &100_000, &1, &false);

    let summary = revora.get_audit_summary(&issuer, &token).unwrap();
    assert_eq!(summary.total_revenue, 100_000);

    // Oracle has no data - querying returns None
    assert!(oracle.get_price(&payout_asset).is_none());
}

// ── Pattern 5: Concurrent Multi-Contract State ───────────────

#[test]
fn cross_contract_concurrent_state_changes() {
    // Demonstrates: interleaving operations across multiple contracts
    // to verify state isolation and correctness.
    let env = Env::default();
    env.mock_all_auths();

    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let registry_id = env.register_contract(None, MockTokenRegistry);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);

    let admin = Address::generate(&env);
    let issuer = Address::generate(&env);

    // Interleave: register tokens in registry and offerings in Revora
    let token_1 = Address::generate(&env);
    let token_2 = Address::generate(&env);
    let token_3 = Address::generate(&env);
    let payout_1 = Address::generate(&env);
    let payout_2 = Address::generate(&env);
    let payout_3 = Address::generate(&env);

    registry.register_token(&admin, &token_1);
    revora.register_offering(&issuer, &token_1, &1_000, &payout_1);

    registry.register_token(&admin, &token_2);
    revora.register_offering(&issuer, &token_2, &2_000, &payout_2);

    registry.register_token(&admin, &token_3);
    revora.register_offering(&issuer, &token_3, &3_000, &payout_3);

    // Verify both contracts have consistent state
    assert_eq!(registry.get_token_count(), 3);
    assert_eq!(revora.get_offering_count(&issuer), 3);

    // All tokens approved in registry
    assert!(registry.is_approved(&token_1));
    assert!(registry.is_approved(&token_2));
    assert!(registry.is_approved(&token_3));

    // All offerings registered in Revora
    assert!(revora.get_offering(&issuer, &token_1).is_some());
    assert!(revora.get_offering(&issuer, &token_2).is_some());
    assert!(revora.get_offering(&issuer, &token_3).is_some());
}

#[test]
fn cross_contract_oracle_price_updates_across_revenue_reports() {
    // Demonstrates: oracle prices can change between revenue reports,
    // and each report's valuation uses the price at query time.
    let env = Env::default();
    env.mock_all_auths();

    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let oracle_id = env.register_contract(None, MockPriceOracle);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let oracle = MockPriceOracleClient::new(&env, &oracle_id);

    let admin = Address::generate(&env);
    let issuer = Address::generate(&env);
    let token = Address::generate(&env);
    let payout_asset = Address::generate(&env);

    revora.register_offering(&issuer, &token, &5_000, &payout_asset);

    // Report revenue at $1.00
    revora.report_revenue(&issuer, &token, &payout_asset, &100_000, &1, &false);
    oracle.set_price(&admin, &payout_asset, &1_000_000, &100);
    let val_1 = oracle.calculate_value(&payout_asset, &100_000);
    assert_eq!(val_1, 100_000); // 100k * $1

    // Price doubles to $2.00
    oracle.set_price(&admin, &payout_asset, &2_000_000, &200);
    revora.report_revenue(&issuer, &token, &payout_asset, &100_000, &2, &false);

    let summary = revora.get_audit_summary(&issuer, &token).unwrap();
    let val_total = oracle.calculate_value(&payout_asset, &summary.total_revenue);
    assert_eq!(val_total, 400_000); // 200k * $2 = $400k at current price
}

// ── Pattern 6: Stress Testing Cross-Contract Interactions ────

#[test]
fn cross_contract_stress_many_registry_tokens() {
    // Demonstrates: external contract handling many entries.
    let env = Env::default();
    env.mock_all_auths();

    let registry_id = env.register_contract(None, MockTokenRegistry);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);
    let admin = Address::generate(&env);

    for _ in 0..50 {
        let token = Address::generate(&env);
        registry.register_token(&admin, &token);
    }

    assert_eq!(registry.get_token_count(), 50);
}

#[test]
fn cross_contract_stress_revora_with_registry_and_oracle() {
    // Demonstrates: full multi-contract stress test.
    let env = Env::default();
    env.mock_all_auths();

    let revora_id = env.register_contract(None, RevoraRevenueShare);
    let registry_id = env.register_contract(None, MockTokenRegistry);
    let oracle_id = env.register_contract(None, MockPriceOracle);
    let revora = RevoraRevenueShareClient::new(&env, &revora_id);
    let registry = MockTokenRegistryClient::new(&env, &registry_id);
    let oracle = MockPriceOracleClient::new(&env, &oracle_id);

    let admin = Address::generate(&env);
    let issuer = Address::generate(&env);

    // Register 10 tokens with offerings, prices, and revenue
    for i in 0..10_u32 {
        let token = Address::generate(&env);
        let payout = Address::generate(&env);

        registry.register_token(&admin, &token);
        revora.register_offering(&issuer, &token, &((i + 1) * 1_000), &payout);
        oracle.set_price(&admin, &payout, &((i as i128 + 1) * 1_000_000), &1000);
        revora.report_revenue(
            &issuer,
            &token,
            &payout,
            &((i as i128 + 1) * 100_000),
            &1,
            &false,
        );
    }

    assert_eq!(registry.get_token_count(), 10);
    assert_eq!(revora.get_offering_count(&issuer), 10);
}
